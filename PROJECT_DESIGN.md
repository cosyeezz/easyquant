# 量化交易系统架构设计原理与实现方案 (v3.0)

## 1. 核心设计哲学：事件驱动与组件解耦

本系统的核心是一种**事件驱动架构 (Event-Driven Architecture)**。这个设计的根本目的是将系统中各个角色的职责彻底分离，实现最大程度的**解耦**，从而达成高度的灵活性和可维护性。

**工作原理：**
系统不依赖于组件间的直接调用，而是通过一个中央的**事件引擎**进行异步通信。

1.  **事件 (Event):** 宣告系统中发生了某件事的信息包。
2.  **事件生产者 (Producer):** 创建并发布事件的组件。
3.  **事件消费者 (Consumer):** 订阅并处理特定事件的组件。
4.  **事件引擎 (Engine):** 系统的中央枢纽，负责从事件队列中，将生产者发布的事件，准确地派发给所有订阅了该事件的消费者。

这种模式的优势在于：生产者和消费者互相独立，可以独立开发、测试和升级，从而构建出一个灵活、可扩展的系统。

---

## 2. 模块一：数据ETL层 (`etl/`) - “数据标准化工厂”

**核心原则：** 将杂乱的原始数据，通过一条可配置、可重复、高性能的“流水线”，加工成干净、标准、随时可用的结构化数据。

### 2.1. 设计原理与核心组件

*   **适配器模式 (Adapter Pattern) - `data_loader/`**
    *   **原理：** 无论数据源是CSV文件、API接口还是其他数据库，数据加载器的职责就像一个“转换插头”，将特定数据源的格式**适配**成系统内部统一、标准的数据结构（如Pandas DataFrame）。
    *   **扩展性实现：** 未来接入新的数据源（如分钟线数据、另类数据），只需增加一个新的`loader`适配器，而无需改动任何下游处理逻辑。

*   **管道/处理器模式 (Pipeline/Handler Pattern) - `processing/`**
    *   **原理：** 数据处理被设计成一系列可插拔的、独立的**纯函数处理器**。数据在一个全局的`上下文`对象中，像在传送带上一样，依次流经这些处理器。
    *   **核心组件:**
        *   **处理器 (Handler):** 一个独立的Python函数，它接收一个全局的 `context` 字典，执行单一、明确的计算任务（如计算复权价），然后将结果写回 `context`。
        *   **上下文 (Context):** 一个在整个管道中传递的字典。它像一个托盘，携带着数据（如DataFrame）、元数据和状态信息，在处理器之间流转。
        *   **管道 (Pipeline):** 一个定义了处理器执行顺序的**函数列表**。
        *   **执行器 (Orchestrator):** 负责驱动整个流程的代码（通常在`scripts/`中）。它初始化`context`，然后按顺序调用管道中的每一个处理器函数。
    *   **扩展性实现：** 新增一个处理步骤（如计算新因子），只需编写一个新的处理器函数，并将其插入到管道列表的适当位置，对其他处理器毫无影响。

*   **规范化分层数据模型 - `storage/`**
    *   **原理：** 摒弃“一张大宽表”的模型，转而采用规范化的多表设计，将不同类型的数据存储在各自独立的表中，便于维护和扩展。
    *   **核心数据表:**
        *   `stock_info` (证券基础信息表): 存储股票代码、名称、上市日期等静态信息。
        *   `trade_calendar` (交易日历表): 存储交易日历数据。
        *   `stock_daily_basic` (日度基础行情表): 存储从外部获取的最原始的日度行情数据，是所有后续计算的“事实之源”。
        *   `factor_technical` (技术指标因子表): 存储基于量价计算出的技术指标，如MA, RSI, MACD等。
        *   `factor_fundamental` (基本面因子表): 存储基于财报数据计算的基本面因子，如PE, PB等。
    *   所有动态表都以 `(stock_code, trade_date)` 作为复合主键。

### 2.2. 关键技术实现方案

*   **如何提高性能？(High Performance)**
    *   **批量化IO:** 在数据写入数据库时，严禁使用`for`循环和单行`INSERT`。应将处理完成的DataFrame暂存入内存（如`io.StringIO`）或临时CSV文件，然后调用数据库原生支持的最高效批量导入命令，如MySQL的 `LOAD DATA LOCAL INfile`。这能将入库性能提升数个数量级。
    *   **并行处理:** 在数据加载和单标的计算环节，可以利用Python的`multiprocessing`库，开启多进程并行处理多个文件或多个股票代码的数据，充分利用多核CPU资源。
    *   **计算优化:** 对于计算密集型任务（如复杂的因子计算），应优先使用Pandas/NumPy的向量化操作，避免使用低效的`.apply()`或行遍历。对于无法向量化的复杂循环，可使用`Numba`等JIT编译器进行加速。

*   **如何避免重复计算？(Idempotency)**
    *   **原理：** 幂等性是ETL流程健壮性的关键，即“对同一批输入数据，无论执行多少次，最终结果都应完全相同”。
    *   **实现方案：**
        1.  建立一个独立的`metadata`元数据表，用于记录**每个数据集**（例如`stock_daily_basic`表）的`last_updated_time`（最后更新时间戳）和`source_hash`（数据源的哈希值或最新修改时间）。
        2.  ETL流程在执行一个管道前，会先进行前置检查：计算输入源（如所有CSV文件）的摘要信息，并与`metadata`表中记录的进行比对。
        3.  **决策:** 只有当摘要信息不匹配时，才执行该管道的处理流程。执行成功后，用新的摘要信息更新`metadata`表。
        4.  提供`--force`命令行参数，以绕过此检查，进行强制刷新。

### 2.3. 示例工作流: 添加新因子 "ATR"

此工作流完美展示了“对修改关闭，对扩展开放”的设计原则。

1.  **修改存储层 (扩展):** 在 `storage/table_schemas.py` 中，为 `factor_technical` 表的定义增加 `atr_14 = Column(Float)` 字段。
2.  **修改处理层 (扩展):** 在 `processing/factor_handlers.py` 中，增加一个新的处理器函数 `calculate_atr(context: dict) -> dict`。该函数从 `context` 中获取基础行情DataFrame，计算ATR指标，并将结果添加回 `context` 中。
3.  **修改管道 (扩展):** 在 `processing/pipeline.py` 中，将新建的 `calculate_atr` 函数添加到主数据处理管道的列表中。
4.  **执行:** 重新运行 `scripts/run_etl_from_csv.py --force`。**无需修改任何现有代码**，系统会自动执行包含新ATR计算的完整流程，并将结果写入数据库。

---

## 3. 核心交互流程：回测 (`backtester/`) 与实盘 (`execution/`)

回测与实盘共享同一套核心逻辑，其差异仅在于**“数据源”**和**“执行器”**这两个“插件”的实现不同。这正是“依赖倒置”和“策略模式”思想的体现。

### 3.1. 核心事件流转原理

1.  **`MarketDataEvent` (行情事件) 产生:**
    *   **回测中:** 由`历史数据源`模块产生。它作为**“时间模拟器”**，按严格的时间顺序从数据库中读取历史K线，逐一生成`MarketDataEvent`。
    *   **实盘中:** 由`实时数据源`模块产生。它连接到券商的实时行情API，每当接收到一个新的Tick或K线时，就生成一个`MarketDataEvent`。

2.  **`SignalEvent` (信号事件) 产生:**
    *   **`Strategy` (策略模块):** 订阅`MarketDataEvent`。当事件到达，其内部算法被触发。若满足条件，则**生产**一个抽象的`SignalEvent`（如“买入AAPL”）。

3.  **`OrderEvent` (订单事件) 产生:**
    *   **`PortfolioManager` (组合管理模块):** 订阅`SignalEvent`。它根据预设的资金管理和风控规则，将抽象信号转化为具体的、可执行的`OrderEvent`（如“买入100股AAPL”）。

4.  **`FillEvent` (成交事件) 产生:**
    *   **回测中:** `OrderEvent`被`模拟执行器`消费。该执行器**“模仿券商”**，根据行情、滑点和手续费模型，计算出模拟成交结果，并**生产**一个`FillEvent`。
    *   **实盘中:** `OrderEvent`被`实盘执行器`消费。它连接到真实的券商交易API，发送订单。然后监听券商的成交回报，一旦收到回报，就**生产**一个`FillEvent`。

5.  **`FillEvent` 消费:**
    *   该事件被**业绩报告模块**和**组合管理模块**同时消费，分别用于更新资金曲线和更新当前实际持仓。

### 3.2. 关键技术实现方案

*   **如何实现扩展性？(Extensibility)**
    *   **策略扩展:** 任何新的交易策略，只需创建一个新的Python文件，在其中实现一个继承自`core/strategy.py`中`StrategyBase`基类的策略类即可。回测/实盘引擎会自动发现并加载它。
    *   **券商接口扩展:** 若要接入新的券商（如CTP），只需仿照`execution/qmt_broker.py`，实现一个新的`BrokerBase`接口。用户在启动实盘系统时，可以通过配置文件指定加载哪个券商的执行器。
    *   **风险/组合管理扩展:** `PortfolioManager`同样可以设计成可插拔的策略模式，用户可以实现不同的资金分配模型（如等权重、市值加权、最小方差等），并在运行时进行选择。

---

## 4. 模块四：测试层 (`tests/`) - “质量保障体系”

**核心原则：** 系统的模块化和解耦设计，天然地使其具备了**高度可测试性**。

**测试原理与实现:**
*   **单元测试:** 由于ETL处理器是纯函数，策略逻辑被封装在独立的类中，我们可以利用`pytest`等框架，脱离整个系统，单独对这些最小单元进行测试。
*   **集成测试:** 我们可以构建一个迷你的、端到端的流程。例如，用一个微型CSV文件作为输入，运行整个ETL流程，然后查询一个临时的测试数据库，验证数据是否被正确写入。
*   **模拟外部依赖 (Mocking):** 在测试中，我们可以用`unittest.mock`库来创建“模拟对象”，以替代真实的外部依赖（如数据库连接、券商API的网络请求）。这使得我们可以在没有网络或真实账户的情况下，验证系统的内部逻辑流转是否正确。

---

## 5. 最终全功能框架目录结构

```
quant/
│
├── .env                    # 环境变量 (数据库密码, QMT路径等)
├── .gitignore
├── SYSTEM_ARCHITECTURE.md  # 本设计文档
│
├── core/                   # [公共核心模块] 回测与实盘共享的底层框架
│   ├── __init__.py
│   ├── event.py            # 定义事件类型
│   ├── engine.py           # 事件驱动引擎
│   ├── strategy.py         # 策略基类
│   ├── portfolio.py        # 投资组合管理基类
│   └── data_structures.py  # 核心数据结构 (Bar, Tick, Order)
│
├── etl/                    # [模块1] 数据清洗与入库
│   ├── __init__.py
│   ├── configs/            # ETL相关配置
│   ├── data_loader/        # 数据加载器 (适配器)
│   ├── processing/         # 数据处理管道和处理器
│   ├── storage/            # 数据库交互 (含高性能写入)
│   ├── scripts/            # ETL执行脚本
│   └── utils/              # ETL专用工具
│
├── backtester/             # [模块2] 策略回测
│   ├── __init__.py
│   ├── runner.py           # [入口] 运行回测的主脚本
│   ├── data_source.py      # 历史数据源
│   ├── execution.py        # 模拟执行器
│   ├── performance.py      # 业绩分析与报告
│   └── strategies/         # [可扩展] 存放用户策略文件的目录
│
├── execution/              # [模块4] 实盘交易
│   ├── __init__.py
│   ├── runner.py           # [入口] 运行实盘交易的主脚本
│   ├── qmt_data_source.py  # QMT实时行情接口
│   ├── qmt_broker.py       # QMT交易接口
│   └── risk_manager.py     # 实盘风险管理
│
└── tests/                  # [模块3] 单元测试与集成测试
```